While the goal of creating a functional Gopher implementation certainly presented itself initially as a challenge, the difficulties themselves presented them in ways we didn't initially expect. Our initial evaluation was that the details in the specs themselves would be difficult to implement whereas it was inevitably the ambiguity in the specs that presented the greatest challenge. 

Our original submission was designed to be a basic, functional Gopher client and server based on our initial understanding of the RFC 1436. The implementation that resulted from this contained some unique decisions. Additionally, some intended and necessary functionality, such as accessing the contents of subdirectories, was attempted but not successfully implemented.

Our server treated every request, or selector string, as a potential file path within the content/ directory, prepending content/ to each file path. Additionally, the server did not differentiate between a request for the root menu, subdirectory menu, or a file. The logic was a simple "content/" + selector. On the client side, we created a simple "echo" style client as the starter code suggests. It was built to send a simple request and print the exact response received, not formatting the incoming response in any special way for the user interface. One (mis)implementation was that the user had to know to send /r/n. This came from a misunderstanding of the specs. Additionally, the client had a fixed buffer size for receiving data, assuming that the server responses would be small and fit within a single packet.

I wouldn't say that we were optimistic going into the interoperability testing, but the results we found were definitely below our expectations. We had issues in connecting and sending messages to every server and every other client had similar issues with our server.

What we quickly learned was that the RFC is much more ambiguous than it seems. While portions are quite specific and straightforward, such as the numbers corresponding to each filetype, others, even how to format a links.txt file, left room for interpretation. This led to a brittle dynamic where clients and servers would work together if and only if they shared the same specific interpretations of the specs. This experience highlighted the benefits of retaining intelligence at the endpoints. If all clients and servers sent the most unedited and basic messages, clients and servers could have used there own implementations to interpret the messages however they like without messing up communication with other parties. 

Our revisions were driven directly by the feedback we received and our lessons from the interoperability testing. This shifted the goal from "make it work for us" to "make it work for others". That said, we did retain certain implementation choices. Namely, the core idea of serving files from content/ and simply appending onto the path was kept.

However, much of the functionality was either fixed or modified to create more universal functionality. One change is the server now distinguishes between different types of requests. Also, the logic for recognizing subdirectories was fixed. Paths ending in / must be for directories. This fix allowed users to actually get past the first layer of our content. On the client side, we no longer require the user to send the specific string "\r\n". Instead, the user simply inputs the empty string and the client knows to send \r\n. Additionally, we fixed our recv() buffer size, increasing it from 1024 to 65536 bytes. 

Most of our testing was pretty straightforward. We would make a change to our client/server and then run through a series of tests to make sure that the intended functionality was either maintained or improved. That said, or series of tests were certainly not very structured or proficient initially. We did not initially take the time to make sure that the entirety of the program still worked after significant changes, which ended up screwing up our implementation in a few ways. 

The most unique part of our testing was checking out another Gopher implementation. We were curious what Gopher looked like elsewhere so we checked out the Floodgap implementation. This was surprisingly helpful and helped answer some questions for us such as what the selector string actually looks like and how it works in practice. 

The main advice I'd give to a future student working on this project is to send and assume the most basic version of messages between client and server. Adding special details to a message going one way or the other to make it easy for your own client and server will inevitably make it more difficult to interact with others' clients and servers.

